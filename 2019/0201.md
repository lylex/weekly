2019.02.01
========

## Technical Related

### [Achieving concurrency in Go](https://medium.com/rungo/achieving-concurrency-in-go-3f84cbf870ca)
> **推荐理由:** 一篇非常深入浅出的文章，从并行并发区别讲起，对比了进程、线程和gorotine之间的区别和联系，还是挺值得一读的。
* 并发
  * 计算机一次处理多个事情的能力，多个事情并非同时
* 并行
  * 同时做多个事情的能力，同时发生
* 进程
  * 进程是内存中的一个程序，包含了地址空间、程序计数器、PID等资源，至少包含一个线程
* 线程
  * 更轻量的进程
  * 不与其他线程共享栈，但共享堆
  * 系统线程由内核调度，一些线程由编程语言提供的运行时环境调度
* go的并发
  * 运行go程序的时候，go的runtime会创建一些线程，来让所有的goroutine来多路复用
  * 任何时刻，一个线程中只有一个goroutine来运行，直到被阻塞了才会让其他的goroutine执行，调度靠go runtime
* 线程和goroutine对比

### [Go http2 和 h2c](https://colobu.com/2018/09/06/Go-http2-%E5%92%8C-h2c/)
> **推荐理由:** 介绍了如何在go中使用http2，以及TLS证书相关。
* 如何实现go http1.1服务器
* http1.1服务器带TLS
  * 如何用命令行创建自签名证书
* 如何自动获取`let's encrypt`免费证书
* 如何在go中使用http2实现服务器

### [Go web 开发中的cookie和session](https://colobu.com/2018/09/28/cookie-and-session-in-go/)
> **推荐理由:** 用简单的代码实例，讲解了如何使用cookie和session，如何更好的作选择
* http.SetCookie，http.Request.Cookie使用示例
* Cookie缺陷
  * 附加于request中，增加流量
  * 浏览器不共享
  * 同一台机器不同用户共享
  * 大小限制
  * 明文
* 加密Cookie
  * 服务器端对称加密后发送，读出来再解密
* Session
  * id作为Cookie给用户浏览器，内容放在服务器
* JWT
  * 把用户的访问权限放在客户端，而且可以保证不被篡改


### [分布式系统原理](https://wenku.baidu.com/view/53b7505777232f60ddcca1e0.html)
> **推荐理由:** 中文讲到了分布式系统的各种概念，作为科普的话还是挺好的，分布式系统不是个容易的东西，用中文讲或许是个不错的选择。
* 概念：利用多台计算机协同解决单台所不能解决的计算存储等问题。
* 节点
  * 无状态节点：不保有数据的节点
  * 带存储状态节点：本地有存储设备保存数据
  * 宕机节点
* 异常
  * 某些节点通信正常，某些节点始终无法正常通信，称为“网络分化”（network partition）
  * TCP不一定意味着可靠，TCP只能保证两个协议栈之间的可靠，不能保证应用层已经正确接受并处理
  * 分布式系统的三种状态：成功，失败，超时
* 副本
  * 数据副本是分布式系统解决数据丢失的唯一手段
  * 服务副本指的是多个节点提供相同服务，一般数据来自其他的节点
  * 副本一致性：
    * 强一致性：任何时刻任何用户拿到的都是最新的数据
    * 单调一致性：任何用户拿到一个更新的值后，下次不会拿到比这个旧的数据
    * 最终一致性：更新成功后，各个副本的数据最终会一致，但时间未知。此时，如果只读一个副本，则可以保证单调一致性。
* 指标
  * 性能（performance）：QPS，（query per second）
  * 可用性（available）：暂停服务时间与正常服务时间的比例
  * 可扩展性（scalability）：通过扩展机器规模提高系统能力的特性
* 数据分布方式
  * 哈希，分布容易，扩展难，也容易出现“数据倾斜”
  * 按数据范围分布
  * 按数据量分布
  * 一致性哈希：使得哈希函数输出值为一个封闭的环，节点随机分布在这个环上。扩容容易，只影响相邻的节点。可以改进为分配虚节点。
* 副本与分布：将数据切分若干数据段，同一个数据段在不同机器上互为副本
* 副本协议
  * 中心化副本控制协议：中心节点协调数据副本数据更新，并发控制由中心节点通过加锁控制完成
    * Primary-secendary协议：中心化，只有一个节点是primary
      * 数据更新都是由primary完成, 外部数据更新操作都发到primary
      * primary进行并发控制，将操作发给secondory
      * primary根据secondory更新的情况决定是否返回结果给外部
  * 去中心化副本控制协议：节点低位对等，节点间通过协商达到一致
    * 效率较中心化低，但不会因为个别节点对整个系统产生大的影响
* Lease机制
  * 中心服务器返回数据时候，顺带发送一个lease，承诺在lease时间内，不修改数据，若要修改数据，中心服务器需等待lease过期
  * 需要假设颁发者和接受者时钟同步
  * lease可以用作中心化集群中对于节点状态判断，中心化节点向其他节点发送lease，确定某个节点为primary
  * lease时间选择是一个折中，一般为10秒
* Quorum机制
  * WARO: write-all-read-one, 牺牲服务可用性，最大程度增强可用性，全部写成功了才提交，任意读一个就行
  * 若5个node，有3个写成功了便成功，读时先读3个节点，如果不是全部最新，则继续读剩下的，知道某个版本满足3个
  * zookeeper使用的paxos协议利用了Quromn机制，每次primary更新数据后都会递增各个节点的xid，后续以此来确定是否成功
* 日志技术
  * redo log
  * check point
* 两阶段提交
  * 写之前向所有的参与者发送写请求，若参与者同意，自己本地写log，发送同意，若不同意，发送不同意，发送者收到后abort写，并发送其他的参与者
* MVCC
* Paxos
* CAP
（TBC）

## Non-technical Related
